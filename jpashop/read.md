# JPA 살펴보기

## 라이브러리
- 의존관계 확인
  - ./gradlew dependencies
- 핵심 라이브러리
  - 스프링 MVC
  - 스프링 ORM
  - JPA, 하이버네이트
  - 스프링 데이터 JPA
- 기타라이브러리
  - H2
  - HikariCP : 커넥션 풀
  - 타임리프
  - 로깅
  - 테스트
  - implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.5.6' 
    - ? ? 파라미터 확인 (쿼리)

## java jar 사용하여 확인하기
1. ./gradlew clean build
2. cd bulid
3. java -jar ~~.jar

## 요구사항 분석
> 기능목록

- 회원 기능
  - 등록
  - 조회
- 상품 기능
  - 등록
  - 수정
  - 조회
- 주문 기능
  - 상품 주문
  - 주문내역 조회
  - 주문 취소
- 기타
  - 상품은 제고 관리가 필요
  - 상품 종류 도서 음반 영화
  - 상품 카테고리로 구분
  - 상품 주문 시 배송 정보 입력

## 참고사항
- 외래키가 있는곳을 연관관계 주인으로 설정
  - 연관관계의 주인은 단순히 외래 키를 누가 관리햐냐의 문제이다.
  - 일:다 관계에서는 다 쪽에 외래키가 있으므로 그렇게 정하면 된다.
- 엔티티 설계시 주의점
  - setter 사용하지말자. => 변경 포인트가 많아 유지보수가 어렵다.
  - 모든 연관관계는 지연로딩으로 설정
    - 즉시로딩은 예측이 어렵고, 어떤 SQL이 실행될지 추적이 어렵다. 특히 N+1 문제가 발생
    - 즉시로딩으로 해놓으면 연관된 객체들에 관한 쿼리가 다 나간다.
    - 연관된 엔티티를 함께 조회하면, fetch join 또는 엔티티 그래프 기능을 사용한다.
    - XToOne -> 기본이 EAGER, 꼭 변경하자.
  - 컬렉션은 필드에서 초기화하자.
    - null에 안전
    - 하이버네이트는 엔티티를 영속화 할 때, 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경, 만약 임의로 생성했다면 하이버네티으 내부 메커니즘에 문제가 발생할 수 있다.
- id를 Long으로 하는 이유
  - int, long이 아닌 Wrapper Class(Long)를 쓰는 이유는 null을 사용할 수 있기 때문입니다. primitive type은 기본값이 0이 되는데, id가 없을 때를 나타낼 수 없습니다.
  - Long과 Integer 중에서 Long을 쓰는 이유는 표현범위 때문입니다.
  - Long이 Integer보다 월등히 많은 수를 표현할 수 있기 때문에 Long을 사용합니다.
  - 물론 Integer의 범위로도 충분하다면 Integer를 사용하셔도 무방합니다.

## 메모리 디비(스프링 부트 지원)
- 테스트 시 자동으로 jdbc:h2:mem:test로 커넥션을 얻어온다.

## 변경감지와 병합
- 준영속 엔티티
  - 영속성 컨텍스트가 더는 관리하지 않는 엔티티
  - 이미 디비에 다녀온 상태(아이디 PK가 이미 있는)
- 준영속 엔티티를 수정하는 2가지 방법
  - 변경감지
  
  ```java
    @Transactional
    public void updateItem(Long itemId, Book param) {
        Item item = itemRepository.findOne(itemId);
        item.setPrice(param.getPrice());
        item.setName(param.getName());
        item.setStockQuantity(param.getStockQuantity());
    }
  
  ```
  - 병합(merge)
    - 준영속 상태를 영속상태로 변경할 때 사용하는 기능
    - merge() 실행
      - 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티 조회
      - 없으면 디비에서 조회 후 1차 캐시 저장
      - 조회한 영속 엔티티에 넘어온 파라미터를 set
      - 영속상태의 엔티티를 반환
  - *주의*
    - `변경 감지 기능을 사용하면 원하는 속상만 update지만, 병합을 사용하면 모든 속성이 변경 => 머지 사용 지양하자`

## entity to dto
엔티티를 DTO로 변환하거나, DTO로 바로 조회하는 두가지 방법은 각각 장단점이 있다. 둘중 상황에
따라서 더 나은 방법을 선택하면 된다. 엔티티로 조회하면 리포지토리 재사용성도 좋고, 개발도 단순해진다.
따라서 권장하는 방법은 다음과 같다.
쿼리 방식 선택 권장 순서
1. 우선 엔티티를 DTO로 변환하는 방법을 선택한다.
2. 필요하면 페치 조인으로 성능을 최적화 한다. 대부분의 성능 이슈가 해결된다.(N+1)
3. 그래도 안되면 DTO로 직접 조회하는 방법을 사용한다.
4. 최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해서 SQL을 직접
   사용한다