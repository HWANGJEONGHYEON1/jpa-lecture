# JPQL


## JPQL 문법
- 엔티티와 속성은 대소문자 구분 (Member, age)
- JPQL 키워드는 대소문자 구분 x (select, from where)
- 엔티티 이름 사용 => 테이블이 아님
- 별칭인 필수
- TypeQuery => 반환타입이 명확할 때
- Query => 불명확
- 결과 조회 API
  - query.getResultList() : 결과가 하나 이상일때, 비었다면 빈 리스트 반환
  - query.getSingleResult() : 결과가 하나일 때, 없거나 많다면 예외 발생

## 프로젝션
- select 절에 조회할 대상을 지정하는 것
- 엔티티, 임베디드 타입, 숫자, 문자 등
- select m from Member m -> 엔티티 프로젝션
- select m.team from Member m -> 엔티티 프로젝션
- select m.address from Member m -> 임베디드
- select m.username, m.age from Member m -> 스칼라 프로젝션

## 페이징
- JPA는 페이징을 두 API 추상화
  - setFirstResult : 조회 시작 위치(0부터 시작)
  - setMaxResults : 조회할 데이터 수 

## 조인
- on
  - 조인 대상 필터링
  - 연관관계 없는 엔티티 외부 조인

## 서브쿼리
- JPA는 WHERE, HAVING 절에서만 서브쿼리 사용가능
- SELECT도 지원(하이버네이트에서 지원)
- FROM 절에서 서브쿼리는 불가능
  - `조인으로 해결` 

## 경로 표현식
- 점을 찍어 객체 그래프를 탐색하는 것
- 상태 필드 : 단순히 값을 저장하기 위한 필드(m.name)
  - 경로 탐색으 끝 탐색 X
- 연관 필드 : 연관관계를 위한 필드
  - 단일 값 연관 필드
    - @ManyToOne, @OneToOne
    - **묵시적 내부조인 발생, 탐색 O**
  - 컬렉션 값 연관 필드
    - 묵시적 내부조인 발생, 탐색 X
- 주의사항 
  - **<i>그냥 묵시적 내부조인 발생하지 않도록 쓰자</i>**

# 패치 조인
- SQL 조인 종류 X
- JPQL 성능최적화를 위해 제공하는 기능
- 연관된 엔티티나 컬렉션을 SQL 한번에 함께 조회하는 기능
- join fetch 명령어 사용

## 엔티티 페치 조인
- 회원을 조회하면서 연관된 팀도 함께 조회 (SQL 한번에)
- SQL을 보면 회원 뿐만아니라 팀도 함께 select
- [JPQL]
  - select m from Member m fetch m.team
- [SQL]
  - select m.*, t.* from member m inner join team t on m.team_id = t.id
- 패치조인과 일반조인 차이
  - 일반조인
    - 연관된 엔티티를 조회하지 않음
    - JPQL은 겨로가를 반환할 때 연관관계 고려 x
    - select 절에 지정한 엔티티만 조회
  - 페치조인
    - 여노간된 엔티티도 함께 조회(즉시 로딩)
    - 페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념  
- 한계
  - 패치 조인 대상에는 별칭을 줄 수 없다. (m)
  - 하이버네이트는 가능하지만, 가급적 사용 X
  - 둘 이상의 컬렉션은 패치조인 할 수 없다.
  - 컬렉션을 패치 조인하면 페이징 API를 사용할 수 없다.
    - 하이버네이트는 경고 로그를 남기고 메모리에서 페이징
    - 일대일, 일대다 같은 단일 값 연관 필드들은 패치 조인해도 페이징 가능
  - 연관된 엔티티들을 SQL 한번으로 조회 - 성능 최적화
  - 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함
  - 실무에서 글로벌 로딩전략은 모두 지연로딩
  - 최적화가 필요한 곳은 페치 조인 적용 

## named 쿼리
- 쿼리 재사용성
- 정적 쿼리
- 어노테이션
- **어플리케이션 로딩시점에 초기화 후 재사용**
- **어플리케이션 로딩 시점에 쿼리 검증**

## 벌크연산
- 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리
- 벌크연산을 먼저 실행
- 수행 후 영속성 컨텍스트 초기화