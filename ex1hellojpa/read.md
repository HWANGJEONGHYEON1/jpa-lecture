
# JPA

## ORM
    Object-relational mapping  
    객체는 객체대로
    관계형 디비는 관계형 디비대로 설계
    ORM 프레임워크가 중간에서 매핑
    대중적인 언어에는 대부분 ORM 기술이 존재
    
## JPA는 모든 트랜잭션 안에서 실행된다.

## JPQL
- `em.createQuery("select m from Member as m", Member.class); // Member 객체를 대상으로 쿼리를 수행`
- 앤티티 객체를 중심으로 개발
- 문제는 검색 쿼리
- 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색
- 모든 DB 데이터를 개체로 변환해서 검색하는 것은 불가능
- 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요


    JPA는 SQL을 추상화한 JPQL 객체 지향 쿼리 언어 제공
    SQL 문법과 유사, SELECT, From, WHERE, GROUP BY, HAVING, JOIN 지원
    앤티티 객체를 대상으로 쿼리

## 영속성 관리

### 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- `EntityManager.persist(entity);`
- 논리적인 개념
- 앤티티 매니저를 통해 영속성 컨텍스트를 접근
- 엔티티 생명주기
  - 비영속
    - 영속성 컨텍스트와 전혀 관계없는 새로우 상태
  - 영속
    - 영속성 컨텍스트에 관리되는 상태
  - 준영속
    - 영속성 컨텍스트에 저장되었다가 분리된 상태 
    - em.detach(객체) -> 영속성 컨텍스트에서 관리하기 때문에 jpa가 관리하지 않는다.
    - em.clear(); -> 영속성 컨텍스트를 비움 -> 1차캐시지우고싶을 때, 테스트케이스 눈으로 보고 싶을때
  - 삭제
- 이점
  - 1차 캐시
    - 성능의 이점을 큰 장점은 없다 => 같은 트랜잭션 내에서만 공유하기 때문
    ```java
            em.persist(member);
            Member findMember = em.find(Member.class, 100L);
            System.out.println("findMember = " + findMember.getName()); // 조회용 Sql이 나가나? => 1차캐시에 저장되어 조회쿼리는 안나옴
    ```
  - 동일성 보장
    - 위의 코드에서 em.find를 두번해도 같은 객체로 본다.
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경감지
    - 마치 자바컬렉션처럼, 이루어진다
    1. 내부적으로 flush() 실행
    2. 엔티티와 기존 일차캐시 스냅샷 값 비교
    3. 쓰기 지연 update sql 생성
    4. flush
  - 지연로딩

### flush
> 영속성 컨텍스트의 변경내용을 DB에 반영  
> 영속성 컨텍스트를 비우는 것은 아님  
- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 쿼리를 DB에 전송(등록, 수정, 삭제)
- 플러시 하는 방법
  - em.flush() 직접 호출
  - 트랜잭션 커밋 시
  - JPQL 쿼리 실행 시

## 객체와 테이블 매핑
> @Entity
- JPA가 관리, 엔티티
- 테이블과 매핑할 클래스는 @Entity필수
- **주의**
  - 기본 생성자 필수
  - final 클래스, enum, interface, inner 클래스 사용 X
  - 저장할 필드에 final 사용 x

## 데이터 베이스 스키마 자동생성
```<property name="hibernate.hbm2ddl.auto" value="create" />```
- DDL을 애플리케이션 실행 시점에 자동생성
- 테이블 중심 -> 객체 중심
- DB 방언을 활용해서 적절한 DB에 맞는 DDL 생성
- 생성된 DDL은 개발 환경에서만 적용
- 생성된 DDL은 운영서버에서 사용하면 안된다.
- 주의점
  - 운영에는 create, create-drop, update는 절대 안된다.
  - 개발 초기단계는 update, create
  - 테스트 서버는 update 또는 validate
  - 스테이징과 운영서버는 validate or none

### @Column
- insertable, updatable : 등록 변경 가능여부
- nullable : NOTNULL 제약조건
- unique : 간단히 유니크 제약조건을 만드는대 잘 사용하지 않음 => 이름이 랜덤으로 생성됨

### @Enumerated
- ORDINAL : Enum이 자리가 바뀌거나 데이터가 바뀌게 되면 디비에는 순서만으로 들어가기 때문에 보기 어렵다
- STRING : 문자 자체로 디비에 들어간다.

## 기본 키 매핑
- Identity 전략
  - 기본 키 생성을 데이터베이스에 위임
  - 주로 auto_increment 전략
  - JPA는 보통 트랜잭션 커밋시점에 insert sql 실행
  - auto_increment는 DB에 insert 후 알 수 있음
  - 이 전략은 em.persist() 시점에 즉시 insert 후 DB에서 식별자 조회

## 연관관계 매핑
- 객체의 양방향 관계
  - 서로 다른 단방향 관계가 2개
- 테이블의 양방향 관계
  - 외래키 하나로 두 테이블의 연관관계를 관리
- 연관관계 주인
  - 양방향 매핑 규칙
    - 객체의 두 관계중 하나를 연관관계 주인으로 지정
    - 연관관계의 주인만이 외래 키를 관리(등록, 수정)
    - 주인이 아니쪽은 readOnly
    - 주인은 mappedBy 속성 x
    - 외래키가 있는곳을 주인으로 설정 (디비 테이블의 N:1인경우 N쪽이 주인)
  - 실수
    - 연관관계의 주인에 값을 입력하지않음
    - 대안
      - `순수 객체상태를 고려하여 양쪽에 값을 셋팅`
      - 연관관계 편의 메소드를 생
- mappedBy
  - 일단 단방향으로 관계를 잡은 후 필요할 때 양방향으로 하면 됌
- 일대일 관계
  - 주 테이블이나 대상 테이블 중에 외래키 선택가능
  - 외래키에 데이터베이스 유니크 제약조건 추가

## 어노테이션
- @JoinColumn
  - 속성
    - name => 매핑할 외래키 이름(필드명 참조하는 테이블의 기본 키 컬럼명)
    - referencedColumnName : 외래키가 참조하는 대상 테이블의 컬럼
- @ManyToOne
  - 속성
    - optional : false로 설정하면 연관된 엔티티가 항상 있어야한다.
    - fetch : 글로벌 패치 전략을 설정한다. (FetchType. EAGER, LAZY)
    - cascade : 영속성 전이 기능을 사용
- @OneToMany
  - 속성
    - mappedBy : 연관관계 주인 필드를 선택
    - fetch
    - cascade

## 상속관계 매핑
- RDB는 상속관계 X
- 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사
- 상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑
- 슈퍼타입 서브타입 논리모델을 실제 물리 모델로 구현하는 방법
  - 각각 테이블로 생성 -> 조인(@Inheritance(strategy = InheritanceType.JOINED))
    - 장점
      - 테이블 정규화
      - 저장공간의 효율화
      - 외래 키 참조 무결성 제약조건 활용
    - 단점
      - 조인 사용
      - 조회 쿼리 복잡
      - insert 쿼리 두번
  - 통합 테이블로 생성 -> 단일 테이블
    - 장점
      - 조인 필요없음
      - 조회 쿼리 단순
    - 단점
      - 컬럼은 모두 null 허용해야함
      - 테이블이 커질수 있음
  - 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략
    - 장점
      - NOT NULL 제약조건 사용가능
      - 명확
    - 단점
      - 여러 자식 테이블을 함께 조회
      - 자식 테이블 통합해서 쿼리하기 어려움, 변경에 치명

## @MappedSuperclass
- 주로 등록일, 수정일, 등록자, 수정자 공통으로 사용되어야할 때
- 상속관계 매핑 X
- 엔티티 X, 테이블과 매핑 X
- 부모클래스를 상속받는 자식 클래스에 매핑정보만 제공
- 조회, 검색 불가
- 추상클래스 권장

## 프록시 
- 특징
  - 객체는 처음 사용할 때 한번만 초기화
  - 프록시 객체가 실제 엔티티로 바뀌는게 아니라, 접근이 가능하다
  - 타입 체크 시 주의해야함 (`== 비교 대신 instanceof 사용해야함`)
  - 영속성 컨텍스트에 찾은 엔티티가 이미 있다면, em.getReference 호출해도 실제 엔티티반환
  - 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때는, 프록시를 초기화하면 에러발생
  - 실제 클래스를 상속받아 만들어짐
  - 실제 클래스와 겉 모양이 같다
  - 사용자 입장에서는 진짜 객체인지 프록시 객체인지 구분하지않고 사용하면 됨 
- em.find() vs em.getReference
  - em.find() : db를 통한 진짜 엔티티 조회
  - em.getReference : 데이터베이스 조회를 미루는 가짜 엔티티 조회

## 지연로딩
- @ManyToOne(fetch = FetchType.LAZY)
- 실제 객체를 사용하는 시점에 초기화

## 즉시로딩
- @ManyToOne(fetch = FetchType.EAGAR)
- 조회를 할 때 한번에 초기화(프록시가 필요없음)

## 프록시와 즉시로딩 주의
- 가급적 지연 로딩만 사용
- 즉시 로딩 적용하면 예상하지 못한 SQL 발생
- 즉시로딩은 N+1 문제를 일으킴
  - 최초 쿼리가 1개인대 추가쿼리가 N개 
- @ManyToOne, @OneToOne은 기본이 즉시 로딩 => `LAZY` 설정
- @OneToMany, @ManyToMany는 기본이 지연로딩

## 영속성 전이 : cascade
- 특정엔티티를 영속 상태로 만들 때, 연관된 엔티티도 함께 영속상태를 만들고 싶을 때
  - ex) 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장 
- 연관관계를 매핑하는 것은 상관없다.
- 종류
  - ALL : 모두 적용
  - PERSIST : 영속
  - REMOVE : 삭제
  - MERGE : 병합
- 고아객체
  - 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
  - `orpahnRemoval = true`
  - delete from Child where id=?
  - 참조하는 곳이 하나일 때 사용해야함
  - 특정 엔티티가 개인 소유할 때 사용
  - 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아객체로 보고 삭제하는 기능
- ALL + orpahnRemoval = true
  - 스스로 생명주기를 관리하는 엔티티는 em.persist() 영속화, em.remove() 제거
  - 부모 엔티티를 통해 자식의 생명주기를 관리
  - DDD의 Aggregate Root 개념을 구현할 때 유용

## 값 타입
- 엔티티 타입
  - @Entity로 정의하는 객체
  - 데이터가 변해도 식별자로 지속해서 추적 가능
- 값 타입
  - 자바의 기본 타입이나 객체
  - 값이 바뀌면 완전히 다른 값
  - 인스턴인 값을 공유하는것 절대 안됨
  - 값을 복사해서 사용
  - 기본 값 타입
    - primitive type
    - wrapper
    - String
    - 생명주기를 엔티티에 의존
    - 값 타입은 공유하면 안됨.
  - 임베디드
    - @Embeddable
    - 속성 재정의 : @AttributeOverride
    - 장점
      - 재사용
      - 높은 응집도
      - 임베디드 타입을 포함한 모든 값 타입은, 값타입을 소유한 엔티티에 생명주기를 의존함.
    - 비교
      - 동일성 비교 : 인스턴스의 참조값을 비교 ==
      - 동등성 비교 : 인스턴스의 값을 비교 equals()
    - 임베디드 타입은 엔티티의 값일 뿐
    - 이 타입을 사용하기 전과 후에 매핑하는 테이블은 똑같다
    - 객체와 테이블을 세밀할게 매핑하는 것이 가능(객체지향스럽게)
    - 잘 설계한 ORM 어플리케이션은 매핑한 테이블 수보다 클래스 수가 더 많다.
    - 객체 타입의 한계
      - `직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다.`
      - 기본타입은 복사를 하지만, 객체타입은 참조 값을 직접 대입하여 막을 수 없음.
      - 공유 참존는 피할 수 없다.
      - 대안
        - `불변 객체` : 생성 시점 이후 절대 값을 변경할 수 없는 객체
        - 생성자로만 값을 설정하고 setter 사용을 안함
        - Integer, String은 자바가 제공하는 불변객체 
  - 컬렉션
    - 값 타입을 하나이상 저장할 때
    - @ElementCollection, @CollectionTable
    - 데이터베이스는 컬렉션을 테이블에 저장할 수 없다.
    - 별도의 테이블이 필요(joincolumn 사용)
    - 값 타입 컬렉션은 영속성 전이 + 고아객체제거 기능을 필수로 가진다.
    - 지연로딩 default
    - 제약사항
      - 값 엔티티와 다르게 식별자 개념이 없다.
      - 값 변경시 추적이 어렵다.
      - 값 타입 컬렉션이 변경사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장
        - 즉 관련된 데이터 다 삭제 후 남은 데이터 insert
      - 값 타입 컬렉션을 매핑하는 테이블은 모두 컬럼을 묶어서 기본키를 구성해야함 => `null x, 중복 x`
    - 대안 => 값 타입 컬렉션 대신 `일대다 관계`

## JPQL
- 특징
  - JPA를 사용하면 엔티티 객체를 중심으로 개발
  - 검색을 할 때 테이블이 아닌 엔티티 객체를 대상으로 검색
  - SQL을 추상화해서 특정 DB에 의존하지 않음
  - 객체지향 SQL
- 문제는 검색 쿼리
- 모든 DB 데이터를 객체로 변환해서 검색하는것은 불가능
- SQL은 데이터베이스 테이블을 대상으로 쿼리
- `QUERY DSL`
  - 자바코드로 JPQL 작성가능
  - JPQL 빌더역할
  - 컴파일 시 오류 발견
  - 동적쿼리 작성 편리
  - 단순
  - 실무 권장

### 기본문법